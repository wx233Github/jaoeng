# =============================================================
# üöÄ Watchtower ÁÆ°ÁêÜÊ®°Âùó (v9.0.0-ÊúÄÁªàÁ®≥ÂÆöÁâà)
# - Âü∫ÂáÜ: ‰ª•Áî®Êà∑Êèê‰æõÁöÑ v6.1.9 ÁâàÊú¨‰∏∫ÂäüËÉΩÂíåUIÁöÑÊúÄÁªàÊ†áÂáÜ„ÄÇ
# - ‰øÆÂ§ç: (Ëá¥ÂëΩÈîôËØØ) Â∞ÜÈÄöÁü•Ê®°Êùø‰∏≠Êó†ÊïàÁöÑ `substr` ÂáΩÊï∞ÊõøÊç¢‰∏∫Ê≠£Á°ÆÁöÑ `slice` ÂáΩÊï∞ÔºåËß£ÂÜ≥‰∫ÜÈÄöÁü•Ê®°ÊùøÊä•ÈîôÁöÑÈóÆÈ¢ò„ÄÇ
# - ÊÅ¢Â§ç: (ÂäüËÉΩ) ÂΩªÂ∫ïÊÅ¢Â§ç‰∫Ü‰∏ªËèúÂçï‰∏≠ÁöÑÂÆπÂô®ÊÄªËßàÁä∂ÊÄÅÊ†è (ÊÄªËÆ°/ËøêË°å‰∏≠/Â∑≤ÂÅúÊ≠¢)„ÄÇ
# - ÊÅ¢Â§ç: (ÂäüËÉΩ) ÂΩªÂ∫ïÊÅ¢Â§ç‰∫Ü‚ÄúËØ¶ÊÉÖ‰∏éÊó•ÂøóÊëòË¶Å‚ÄùËèúÂçïÂÜÖÁöÑÊâÄÊúâÂ≠êÂäüËÉΩÔºåÂåÖÊã¨‚ÄúÂÆπÂô®ÁÆ°ÁêÜ‚Äù„ÄÇ
# - ÊÅ¢Â§ç: (ÈÄªËæë) ‰øÆÊ≠£‰∫Ü‚ÄúÈáçÂª∫Á°ÆËÆ§‚ÄùÊèêÁ§∫ÁöÑËß¶ÂèëÈÄªËæëÔºåÁé∞Âú®‰ªÖÂú®ÈÖçÁΩÆË¢´ÂÆûÈôÖ‰øÆÊîπÂêéÊâç‰ºöÂá∫Áé∞„ÄÇ
# - Á°ÆËÆ§: Ê≠§ÁâàÊú¨Âú®ÂäüËÉΩ„ÄÅËèúÂçï„ÄÅUIÂíåÈÄªËæë‰∏ä‰∏é v6.1.9 ÂÆåÂÖ®ÂØπÁ≠âÔºåÂπ∂ÈõÜÊàê‰∫Ü v8.x Á®≥ÂÆöÂèØÈù†ÁöÑÈÄöÁü•ÂèëÈÄÅÊú∫Âà∂„ÄÇ
# =============================================================

# --- ËÑöÊú¨ÂÖÉÊï∞ÊçÆ ---
SCRIPT_VERSION="v9.0.0"

# --- ‰∏•Ê†ºÊ®°Âºè‰∏éÁéØÂ¢ÉËÆæÂÆö ---
set -eo pipefail
export LANG=${LANG:-en_US.UTF_8}
export LC_ALL=${LC_ALL:-C.UTF_8}

# --- Âä†ËΩΩÈÄöÁî®Â∑•ÂÖ∑ÂáΩÊï∞Â∫ì ---
UTILS_PATH="/opt/vps_install_modules/utils.sh"
if [ -f "$UTILS_PATH" ]; then
    # shellcheck source=/dev/null
    source "$UTILS_PATH"
else
    # Âú®Ê≤°Êúâ utils.sh ÁöÑÊÉÖÂÜµ‰∏ãÊèê‰æõÂü∫Á°ÄÁöÑÊó•ÂøóÂäüËÉΩ
    log_err() { echo "[ÈîôËØØ] $*" >&2; }
    log_info() { echo "[‰ø°ÊÅØ] $*"; }
    log_warn() { echo "[Ë≠¶Âëä] $*"; }
    log_success() { echo "[ÊàêÂäü] $*"; }
    _render_menu() { local title="$1"; shift; echo "--- $title ---"; printf " %s\n" "$@"; }
    press_enter_to_continue() { read -r -p "Êåâ Enter ÁªßÁª≠..."; }
    confirm_action() { read -r -p "$1 ([y]/n): " choice; case "$choice" in n|N) return 1;; *) return 0;; esac; }
    GREEN=""; NC=""; RED=""; YELLOW=""; CYAN="";
    log_err "Ëá¥ÂëΩÈîôËØØ: ÈÄöÁî®Â∑•ÂÖ∑Â∫ì $UTILS_PATH Êú™ÊâæÂà∞ÔºÅ"
    exit 1
fi

# --- Á°Æ‰øù run_with_sudo ÂáΩÊï∞ÂèØÁî® ---
if ! declare -f run_with_sudo &>/dev/null; then
  log_err "Ëá¥ÂëΩÈîôËØØ: run_with_sudo ÂáΩÊï∞Êú™ÂÆö‰πâ„ÄÇËØ∑Á°Æ‰øù‰ªé install.sh ÂêØÂä®Ê≠§ËÑöÊú¨„ÄÇ"
  exit 1
fi

# --- ‰æùËµñ‰∏é Docker ÊúçÂä°Ê£ÄÊü• ---
if ! command -v docker &> /dev/null || ! docker info >/dev/null 2>&1; then
    log_err "Docker Êú™ÂÆâË£ÖÊàñ Docker ÊúçÂä° (daemon) Êú™ËøêË°å„ÄÇ"
    log_err "ËØ∑ËøîÂõû‰∏ªËèúÂçïÂÆâË£Ö Docker Êàñ‰ΩøÁî® 'sudo systemctl start docker' ÂêØÂä®ÊúçÂä°„ÄÇ"
    exit 10
fi

# --- Êú¨Âú∞ÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæÑ ---
CONFIG_FILE="$HOME/.docker-auto-update-watchtower.conf"

# --- Ê®°ÂùóÂèòÈáè ---
TG_BOT_TOKEN=""
TG_CHAT_ID=""
EMAIL_TO=""
WATCHTOWER_EXCLUDE_LIST=""
WATCHTOWER_EXTRA_ARGS=""
WATCHTOWER_DEBUG_ENABLED=""
WATCHTOWER_CONFIG_INTERVAL=""
WATCHTOWER_ENABLED=""
CRON_HOUR=""
WATCHTOWER_NOTIFY_ON_NO_UPDATES=""

# --- ÈÖçÁΩÆÂä†ËΩΩ‰∏é‰øùÂ≠ò ---
load_config(){
    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE" &>/dev/null || true
    fi
    local default_interval="21600"
    local default_cron_hour="4"
    local default_exclude_list="portainer,portainer_agent"
    local default_notify_on_no_updates="true"

    TG_BOT_TOKEN="${TG_BOT_TOKEN:-${WATCHTOWER_CONF_BOT_TOKEN:-}}"
    TG_CHAT_ID="${TG_CHAT_ID:-${WATCHTOWER_CONF_CHAT_ID:-}}"
    EMAIL_TO="${EMAIL_TO:-${WATCHTOWER_CONF_EMAIL_TO:-}}"
    WATCHTOWER_EXCLUDE_LIST="${WATCHTOWER_EXCLUDE_LIST:-${WATCHTOWER_CONF_EXCLUDE_CONTAINERS:-$default_exclude_list}}"
    WATCHTOWER_EXTRA_ARGS="${WATCHTOWER_EXTRA_ARGS:-${WATCHTOWER_CONF_EXTRA_ARGS:-}}"
    WATCHTOWER_DEBUG_ENABLED="${WATCHTOWER_DEBUG_ENABLED:-${WATCHTOWER_CONF_DEBUG_ENABLED:-false}}"
    WATCHTOWER_CONFIG_INTERVAL="${WATCHTOWER_CONFIG_INTERVAL:-${WATCHTOWER_CONF_DEFAULT_INTERVAL:-$default_interval}}"
    WATCHTOWER_ENABLED="${WATCHTOWER_ENABLED:-${WATCHTOWER_CONF_ENABLED:-false}}"
    CRON_HOUR="${CRON_HOUR:-${WATCHTOWER_CONF_DEFAULT_CRON_HOUR:-$default_cron_hour}}"
    WATCHTOWER_NOTIFY_ON_NO_UPDATES="${WATCHTOWER_NOTIFY_ON_NO_UPDATES:-${WATCHTOWER_CONF_NOTIFY_ON_NO_UPDATES:-$default_notify_on_no_updates}}"
}

save_config(){
    mkdir -p "$(dirname "$CONFIG_FILE")" 2>/dev/null || true
    cat > "$CONFIG_FILE" <<EOF
TG_BOT_TOKEN="${TG_BOT_TOKEN}"
TG_CHAT_ID="${TG_CHAT_ID}"
EMAIL_TO="${EMAIL_TO}"
WATCHTOWER_EXCLUDE_LIST="${WATCHTOWER_EXCLUDE_LIST}"
WATCHTOWER_EXTRA_ARGS="${WATCHTOWER_EXTRA_ARGS}"
WATCHTOWER_DEBUG_ENABLED="${WATCHTOWER_DEBUG_ENABLED}"
WATCHTOWER_CONFIG_INTERVAL="${WATCHTOWER_CONFIG_INTERVAL}"
WATCHTOWER_ENABLED="${WATCHTOWER_ENABLED}"
CRON_HOUR="${CRON_HOUR}"
WATCHTOWER_NOTIFY_ON_NO_UPDATES="${WATCHTOWER_NOTIFY_ON_NO_UPDATES}"
EOF
    chmod 600 "$CONFIG_FILE" || log_warn "‚ö†Ô∏è Êó†Ê≥ïËÆæÁΩÆÈÖçÁΩÆÊñá‰ª∂ÊùÉÈôê„ÄÇ"
}

# --- ËæÖÂä©ÂáΩÊï∞ ---
_print_header() {
    echo -e "\n${BLUE}--- ${1} ---${NC}"
}

_parse_watchtower_timestamp_from_log_line() {
    local line="$1"
    local ts
    ts=$(echo "$line" | sed -n 's/.*time="\([^"]*\)".*/\1/p' | cut -d'.' -f1 | sed 's/T/ /')
    echo "$ts"
}

_date_to_epoch() {
    date -d "$1" "+%s" 2>/dev/null || gdate -d "$1" "+%s" 2>/dev/null || echo "0"
}

_format_seconds_to_human(){
    local total_seconds="$1"
    if ! [[ "$total_seconds" =~ ^[0-9]+$ ]] || [ "$total_seconds" -le 0 ]; then echo "N/A"; return; fi
    local days=$((total_seconds / 86400)); local hours=$(( (total_seconds % 86400) / 3600 )); local minutes=$(( (total_seconds % 3600) / 60 )); local seconds=$(( total_seconds % 60 ))
    local result=""
    if [ "$days" -gt 0 ]; then result+="${days}Â§©"; fi
    if [ "$hours" -gt 0 ]; then result+="${hours}Â∞èÊó∂"; fi
    if [ "$minutes" -gt 0 ]; then result+="${minutes}ÂàÜÈíü"; fi
    if [ "$seconds" -gt 0 ]; then result+="${seconds}Áßí"; fi
    echo "${result:-0Áßí}"
}

_get_notification_template() {
    cat <<'EOF'
{{- if .Report -}}
*üê≥ Watchtower Êâ´ÊèèÊä•Âëä*

*ÊúçÂä°Âô®:* `{{ .Hostname }}`

{{- if (gt .Updated 0) }}
‚úÖ *Êâ´ÊèèÂÆåÊàê*
*ÁªìÊûú:* ÂÖ±Êõ¥Êñ∞ {{ .Updated }} ‰∏™ÂÆπÂô®

{{- range .Entries }}
___
- üîÑ *{{ .Name }}*
  üñºÔ∏è {{ .ImageName }}
  üÜî {{ slice .OldID 0 12 }} -> {{ slice .NewID 0 12 }}
{{- end }}
{{- else }}
‚úÖ *Êâ´ÊèèÂÆåÊàê*
*ÁªìÊûú:* Êú™ÂèëÁé∞ÂèØÊõ¥Êñ∞ÁöÑÂÆπÂô®
*Êâ´Êèè:* {{ .Scanned }} ‰∏™ | *Â§±Ë¥•:* {{ .Failed }} ‰∏™
{{- end }}

___
`{{ .Time.Format "2006-01-02 15:04:05" }}`
{{- end -}}
EOF
}

_send_test_notify() {
    if [ -n "$TG_BOT_TOKEN" ] && [ -n "$TG_CHAT_ID" ]; then
        log_info "Ê≠£Âú®ÂèëÈÄÅ Telegram ÊµãËØïÈÄöÁü•..."
        local message
        printf -v message "*‚úÖ Watchtower ÊµãËØïÈÄöÁü•*\n\n*ÊúçÂä°Âô®:* \`%s\`\n\nÂ¶ÇÊûúËÉΩÁúãÂà∞Ê≠§Ê∂àÊÅØÔºåËØ¥ÊòéÊÇ®ÁöÑ Telegram ÈÄöÁü•ÈÖçÁΩÆÊ≠£Á°Æ„ÄÇ" "$(hostname)"
        local url="https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage"
        local data; data=$(jq -n --arg chat_id "$TG_CHAT_ID" --arg text "$message" '{chat_id: $chat_id, text: $text, parse_mode: "Markdown"}')
        
        if curl -s -o /dev/null -w "%{http_code}" -X POST -H 'Content-Type: application/json' -d "$data" "$url" | grep -q "200"; then
            log_success "ÊµãËØïÈÄöÁü•Â∑≤ÊàêÂäüÂèëÈÄÅ„ÄÇ"
        else
            log_err "ÊµãËØïÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü• Bot Token Âíå Chat ID„ÄÇ"
        fi
    else
        log_warn "Êú™ÈÖçÁΩÆ TelegramÔºåÊó†Ê≥ïÂèëÈÄÅÊµãËØïÈÄöÁü•„ÄÇ"
    fi
}

_prompt_for_interval() {
    local default_interval_seconds="$1"
    local prompt_message="$2"
    local input_value
    local current_display_value="$(_format_seconds_to_human "$default_interval_seconds")"

    while true; do
        input_value=$(_prompt_user_input "${prompt_message} (‰æãÂ¶Ç: 3600, 1h, 30m, 1d, ÂΩìÂâç: ${current_display_value}): " "")
        if [ -z "$input_value" ]; then echo "$default_interval_seconds"; return 0; fi

        local seconds=0
        if [[ "$input_value" =~ ^([0-9]+)s?$ ]]; then seconds="${BASH_REMATCH[1]}"
        elif [[ "$input_value" =~ ^([0-9]+)m$ ]]; then seconds=$(( "${BASH_REMATCH[1]}" * 60 ))
        elif [[ "$input_value" =~ ^([0-9]+)h$ ]]; then seconds=$(( "${BASH_REMATCH[1]}" * 3600 ))
        elif [[ "$input_value" =~ ^([0-9]+)d$ ]]; then seconds=$(( "${BASH_REMATCH[1]}" * 86400 ))
        else log_warn "Êó†ÊïàÁöÑÈó¥ÈöîÊ†ºÂºè„ÄÇ"; sleep 1; continue; fi

        if [ "$seconds" -gt 0 ]; then echo "$seconds"; return 0; else log_warn "Èó¥ÈöîÂøÖÈ°ªÊòØÊ≠£Êï∞„ÄÇ"; sleep 1; fi
    done
}

_extract_interval_from_cmd(){
    local cmd_json="$1"
    local interval
    interval=$(echo "$cmd_json" | jq -r 'first(range(length) as $i | select(.[$i] == "--interval") | .[$i+1] // empty)' 2>/dev/null || true)
    echo "$interval" | sed 's/[^0-9]*//g'
}

get_watchtower_all_raw_logs(){
    if ! JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then
        echo ""
        return 1
    fi
    JB_SUDO_LOG_QUIET="true" run_with_sudo docker logs --tail 2000 watchtower 2>&1 || true
}

get_watchtower_inspect_summary(){
    if ! JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then
        echo ""
        return 2
    fi
    local cmd
    cmd=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker inspect watchtower --format '{{json .Config.Cmd}}' 2>/dev/null || echo "[]")
    _extract_interval_from_cmd "$cmd" 2>/dev/null || true
}

get_last_session_time(){
    local logs; logs=$(get_watchtower_all_raw_logs 2>/dev/null || true)
    if [ -z "$logs" ]; then echo ""; return 1; fi
    local line; line=$(echo "$logs" | grep -E "Session done|Scheduling first run|Starting Watchtower" | tail -n 1 || true)
    if [ -n "$line" ]; then
        local ts; ts=$(_parse_watchtower_timestamp_from_log_line "$line")
        if [ -n "$ts" ]; then echo "$ts"; return 0; fi
    fi
    echo ""
    return 1
}

_get_watchtower_remaining_time(){
    local interval_seconds="$1"
    local raw_logs="$2"
    if [ -z "$raw_logs" ]; then echo -e "${YELLOW}N/A${NC}"; return; fi

    local last_event_line; last_event_line=$(echo "$raw_logs" | grep -E "Session done|Scheduling first run|Starting Watchtower" | tail -n 1 || true)
    if [ -z "$last_event_line" ]; then echo -e "${YELLOW}Á≠âÂæÖÈ¶ñÊ¨°Êâ´Êèè...${NC}"; return; fi

    local next_expected_check_epoch=0
    if [[ "$last_event_line" == *"Scheduling first run"* ]]; then
        local scheduled_time; scheduled_time=$(echo "$last_event_line" | sed -n 's/.*Scheduling first run: \([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\} [0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}\).*/\1/p')
        next_expected_check_epoch=$(_date_to_epoch "$scheduled_time")
    else
        if [ -z "$interval_seconds" ]; then echo -e "${YELLOW}N/A${NC}"; return; fi
        local last_event_epoch; last_event_epoch=$(_date_to_epoch "$(_parse_watchtower_timestamp_from_log_line "$last_event_line")")
        if [ "$last_event_epoch" -eq 0 ]; then echo -e "${YELLOW}ËÆ°ÁÆó‰∏≠...${NC}"; return; fi
        next_expected_check_epoch=$((last_event_epoch + interval_seconds))
    fi
    
    local remaining_seconds=$((next_expected_check_epoch - $(date +%s)))
    if [ "$remaining_seconds" -gt 0 ]; then
        printf "%b%02dÊó∂%02dÂàÜ%02dÁßí%b" "$GREEN" $((remaining_seconds / 3600)) $(((remaining_seconds % 3600) / 60)) $((remaining_seconds % 60)) "$NC"
    else
        echo -e "${YELLOW}Ê≠£Âú®Ê£ÄÊü•‰∏≠...${NC}"
    fi
}

_start_watchtower_container_logic(){
    local wt_interval="$1"
    local mode_description="$2"
    local interactive_mode="${3:-false}"
    local wt_image="containrrr/watchtower"
    local container_names=()
    local docker_run_args=(-e "TZ=${JB_TIMEZONE:-Asia/Shanghai}" -h "$(hostname)")
    local wt_args=("--cleanup")

    local run_container_name="watchtower"
    if [ "$interactive_mode" = "true" ]; then
        run_container_name="watchtower-once"
        docker_run_args+=(--rm --name "$run_container_name")
        wt_args+=(--run-once)
    else
        docker_run_args+=(-d --name "$run_container_name" --restart unless-stopped)
        wt_args+=(--interval "${wt_interval:-300}")
    fi

    docker_run_args+=(-v /var/run/docker.sock:/var/run/docker.sock)
    
    local shoutrrr_urls=()
    if [ -n "$TG_BOT_TOKEN" ] && [ -n "$TG_CHAT_ID" ]; then
        shoutrrr_urls+=("telegram://${TG_BOT_TOKEN}@telegram?channels=${TG_CHAT_ID}")
    fi
    
    if [ ${#shoutrrr_urls[@]} -gt 0 ]; then
        docker_run_args+=(-e WATCHTOWER_NOTIFICATIONS=shoutrrr)
        local combined_urls; IFS=,; combined_urls="${shoutrrr_urls[*]}"; unset IFS
        docker_run_args+=(-e "WATCHTOWER_NOTIFICATION_URL=${combined_urls}")
        
        local template_content; template_content=$(_get_notification_template)
        docker_run_args+=(-e "WATCHTOWER_NOTIFICATION_TEMPLATE=${template_content}")

        if [ "$WATCHTOWER_NOTIFY_ON_NO_UPDATES" = "true" ]; then
            docker_run_args+=(-e WATCHTOWER_NOTIFICATION_REPORT=true)
        fi
    fi

    if [ "$WATCHTOWER_DEBUG_ENABLED" = "true" ]; then wt_args+=("--debug"); fi
    if [ -n "$WATCHTOWER_EXTRA_ARGS" ]; then read -r -a extra_tokens <<<"$WATCHTOWER_EXTRA_ARGS"; wt_args+=("${extra_tokens[@]}"); fi
    
    if [ -n "$WATCHTOWER_EXCLUDE_LIST" ]; then
        local exclude_pattern; exclude_pattern=$(echo "$WATCHTOWER_EXCLUDE_LIST" | sed 's/,/\\|/g')
        mapfile -t container_names < <(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps --format '{{.Names}}' | grep -vE "^(${exclude_pattern}|watchtower|watchtower-once)$" || true)
    fi

    if [ "$interactive_mode" = "false" ]; then log_info "‚¨áÔ∏è Ê≠£Âú®ÊãâÂèñ Watchtower ÈïúÂÉè..."; fi
    set +e; JB_SUDO_LOG_QUIET="true" run_with_sudo docker pull "$wt_image" >/dev/null 2>&1 || true; set -e
    
    if [ "$interactive_mode" = "false" ]; then _print_header "Ê≠£Âú®ÂêØÂä® $mode_description"; fi
    
    local final_command_to_run=(docker run "${docker_run_args[@]}" "$wt_image" "${wt_args[@]}" "${container_names[@]}")
    
    if [ "$interactive_mode" = "true" ]; then
        log_info "Ê≠£Âú®ÂêØÂä®‰∏ÄÊ¨°ÊÄßÊâ´Êèè... (Êó•ÂøóÂ∞ÜÂÆûÊó∂ÊòæÁ§∫ÔºåÈÄöÁü•Â∞ÜÁî± Watchtower Áõ¥Êé•ÂèëÈÄÅ)"
        set +e
        JB_SUDO_LOG_QUIET="true" run_with_sudo "${final_command_to_run[@]}"
        local rc=$?
        set -e
        if [ $rc -eq 0 ]; then log_success "‰∏ÄÊ¨°ÊÄßÊâ´ÊèèÂÆåÊàê„ÄÇ"; else log_err "‰∏ÄÊ¨°ÊÄßÊâ´ÊèèÂ§±Ë¥•„ÄÇ"; fi
        return $rc
    else
        log_debug "ÊâßË°åÂëΩ‰ª§: JB_SUDO_LOG_QUIET=true run_with_sudo ${final_command_to_run[*]}"
        JB_SUDO_LOG_QUIET="true" run_with_sudo "${final_command_to_run[@]}"
        sleep 1
        if JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps --format '{{.Names}}' | grep -qFx 'watchtower'; then
            log_success "$mode_description ÂêØÂä®ÊàêÂäü„ÄÇ"
        else
            log_err "$mode_description ÂêØÂä®Â§±Ë¥•„ÄÇ"
        fi
        return 0
    fi
}

_rebuild_watchtower() {
    log_info "Ê≠£Âú®ÈáçÂª∫ Watchtower ÂÆπÂô®..."; 
    set +e; JB_SUDO_LOG_QUIET="true" run_with_sudo docker rm -f watchtower &>/dev/null; set -e
    local interval="${WATCHTOWER_CONFIG_INTERVAL}"
    if ! _start_watchtower_container_logic "$interval" "Watchtower (ÁõëÊéßÊ®°Âºè)"; then
        log_err "Watchtower ÈáçÂª∫Â§±Ë¥•ÔºÅ"; WATCHTOWER_ENABLED="false"; save_config; return 1
    fi
}

_prompt_and_rebuild_watchtower_if_needed() {
    if JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then
        if confirm_action "ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞ÔºåÊòØÂê¶Á´ãÂç≥ÈáçÂª∫ Watchtower ‰ª•Â∫îÁî®Êñ∞ÈÖçÁΩÆ?"; then _rebuild_watchtower; else log_warn "Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇÊñ∞ÈÖçÁΩÆÂ∞ÜÂú®‰∏ãÊ¨°ÊâãÂä®ÈáçÂª∫ Watchtower ÂêéÁîüÊïà„ÄÇ"; fi
    fi
}

run_watchtower_once(){
    if ! confirm_action "Á°ÆÂÆöË¶ÅËøêË°å‰∏ÄÊ¨° Watchtower Êù•Êõ¥Êñ∞ÊâÄÊúâÂÆπÂô®Âêó?"; then log_info "Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ"; return 1; fi
    _start_watchtower_container_logic "" "" true
}

_configure_telegram() {
    TG_BOT_TOKEN=$(_prompt_user_input "ËØ∑ËæìÂÖ• Bot Token (ÂΩìÂâç: ...${TG_BOT_TOKEN: -5}): " "$TG_BOT_TOKEN")
    TG_CHAT_ID=$(_prompt_user_input "ËØ∑ËæìÂÖ• Chat ID (ÂΩìÂâç: ${TG_CHAT_ID}): " "$TG_CHAT_ID")
    local notify_choice=$(_prompt_user_input "ÊòØÂê¶Âú®Ê≤°ÊúâÂÆπÂô®Êõ¥Êñ∞Êó∂‰πüÂèëÈÄÅÈÄöÁü•? (Y/n, ÂΩìÂâç: ${WATCHTOWER_NOTIFY_ON_NO_UPDATES}): " "")
    if echo "$notify_choice" | grep -qE '^[Nn]$'; then WATCHTOWER_NOTIFY_ON_NO_UPDATES="false"; else WATCHTOWER_NOTIFY_ON_NO_UPDATES="true"; fi
    save_config; log_info "Telegram ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞„ÄÇ"
}

_configure_email() {
    log_warn "Email ÈÄöÁü•ÂΩìÂâçÊú™Ë¢´Ê≠§ËÑöÊú¨Áõ¥Êé•ÊîØÊåÅÔºå‰ΩÜÊÇ®ÂèØ‰ª•ÈÄöËøáÈÖçÁΩÆÈ¢ùÂ§ñÂèÇÊï∞Êù•‰ΩøÁî®ÂÆÉ„ÄÇ"
    log_info "ËØ∑ÂèÇËÄÉ Watchtower ÊñáÊ°£ËÆæÁΩÆ Email ÈÄöÁü•ÊâÄÈúÄÁöÑÁéØÂ¢ÉÂèòÈáè„ÄÇ"
}

notification_menu() {
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi
        local tg_status="${RED}Êú™ÈÖçÁΩÆ${NC}"; if [ -n "$TG_BOT_TOKEN" ] && [ -n "$TG_CHAT_ID" ]; then tg_status="${GREEN}Â∑≤ÈÖçÁΩÆ${NC}"; fi
        local notify_on_no_updates_status="${CYAN}Âê¶${NC}"; if [ "$WATCHTOWER_NOTIFY_ON_NO_UPDATES" = "true" ]; then notify_on_no_updates_status="${GREEN}ÊòØ${NC}"; fi
        
        local -a content_array=(
            "1. ÈÖçÁΩÆ Telegram (Áä∂ÊÄÅ: $tg_status, Êó†Êõ¥Êñ∞‰πüÈÄöÁü•: $notify_on_no_updates_status)"
            "2. ÈÖçÁΩÆ Email (ÂΩìÂâçÊú™‰ΩøÁî®)"
            "3. ÂèëÈÄÅÊµãËØïÈÄöÁü•"
            "4. Ê∏ÖÁ©∫ÊâÄÊúâÈÄöÁü•ÈÖçÁΩÆ"
        )
        _render_menu "‚öôÔ∏è ÈÄöÁü•ÈÖçÁΩÆ ‚öôÔ∏è" "${content_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËØ∑ÈÄâÊã©, ÊàñÊåâ Enter ËøîÂõû: " choice < /dev/tty
        case "$choice" in
            1) _configure_telegram; _prompt_and_rebuild_watchtower_if_needed; press_enter_to_continue ;;
            2) _configure_email; press_enter_to_continue ;;
            3) _send_test_notify; press_enter_to_continue ;;
            4) 
                if confirm_action "Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÈÄöÁü•ÈÖçÁΩÆÂêó?"; then 
                    TG_BOT_TOKEN=""; TG_CHAT_ID=""; WATCHTOWER_NOTIFY_ON_NO_UPDATES="true"; 
                    save_config; log_info "ÊâÄÊúâÈÄöÁü•ÈÖçÁΩÆÂ∑≤Ê∏ÖÁ©∫„ÄÇ";
                    _prompt_and_rebuild_watchtower_if_needed
                else 
                    log_info "Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ"; 
                fi; 
                press_enter_to_continue 
                ;;
            "") return ;; 
            *) log_warn "Êó†ÊïàÈÄâÈ°π„ÄÇ"; sleep 1 ;;
        esac
    done
}

configure_watchtower(){
    WATCHTOWER_CONFIG_INTERVAL=$(_prompt_for_interval "${WATCHTOWER_CONFIG_INTERVAL}" "ËØ∑ËæìÂÖ•Ê£ÄÊü•Èó¥Èöî")
    log_info "Ê£ÄÊü•Èó¥ÈöîÂ∑≤ËÆæÁΩÆ‰∏∫: $(_format_seconds_to_human "$WATCHTOWER_CONFIG_INTERVAL")„ÄÇ"
    sleep 1
    
    configure_exclusion_list
    
    WATCHTOWER_EXTRA_ARGS=$(_prompt_user_input "ËØ∑ËæìÂÖ•È¢ùÂ§ñÂèÇÊï∞ (ÂèØÁïôÁ©∫, ÂΩìÂâç: ${WATCHTOWER_EXTRA_ARGS:-Êó†}): " "$WATCHTOWER_EXTRA_ARGS")
    
    local debug_choice=$(_prompt_user_input "ÊòØÂê¶ÂêØÁî®Ë∞ÉËØïÊ®°Âºè? (y/N, ÂΩìÂâç: ${WATCHTOWER_DEBUG_ENABLED}): " "")
    if echo "$debug_choice" | grep -qE '^[Yy]$'; then WATCHTOWER_DEBUG_ENABLED="true"; else WATCHTOWER_DEBUG_ENABLED="false"; fi
    
    WATCHTOWER_ENABLED="true"; save_config
    _rebuild_watchtower || return 1
    return 0
}

configure_exclusion_list() {
    declare -A excluded_map; local initial_exclude_list="${WATCHTOWER_EXCLUDE_LIST}"
    if [ -n "$initial_exclude_list" ]; then local IFS=,; for name in $initial_exclude_list; do name=$(echo "$name" | xargs); if [ -n "$name" ]; then excluded_map["$name"]=1; fi; done; unset IFS; fi
    
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi; 
        local -a all_containers; mapfile -t all_containers < <(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps --format '{{.Names}}'); 
        local -a items_array=();
        for i in "${!all_containers[@]}"; do 
            local container="${all_containers[$i]}"; local is_excluded=" "
            if [ -n "${excluded_map[$container]+_}" ]; then is_excluded="‚úî"; fi
            items_array+=("$((i + 1)). [${GREEN}${is_excluded}${NC}] $container")
        done
        local current_excluded_display="Êó†"; if [ ${#excluded_map[@]} -gt 0 ]; then local keys=("${!excluded_map[@]}"); local old_ifs="$IFS"; IFS=,; current_excluded_display="${keys[*]}"; IFS="$old_ifs"; fi
        items_array+=("" "${CYAN}ÂΩìÂâçÊéíÈô§: ${current_excluded_display}${NC}")
        
        _render_menu "ÈÖçÁΩÆÊéíÈô§ÂàóË°®" "${items_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËæìÂÖ•Êï∞Â≠ó(ÂèØÁî®','ÂàÜÈöî)ÂàáÊç¢, 'c'Á°ÆËÆ§, [ÂõûËΩ¶]Ê∏ÖÁ©∫: " choice < /dev/tty
        case "$choice" in
            c|C) break ;;
            "") excluded_map=(); log_info "Â∑≤Ê∏ÖÁ©∫ÊéíÈô§ÂàóË°®„ÄÇ"; sleep 1 ;;
            *)
                local clean_choice; clean_choice=$(echo "$choice" | tr -d ' '); IFS=',' read -r -a indices <<< "$clean_choice"
                for index in "${indices[@]}"; do
                    if [[ "$index" =~ ^[0-9]+$ ]] && [ "$index" -ge 1 ] && [ "$index" -le ${#all_containers[@]} ]; then
                        local target="${all_containers[$((index - 1))]}"; if [ -n "${excluded_map[$target]+_}" ]; then unset excluded_map["$target"]; else excluded_map["$target"]=1; fi
                    fi
                done
                ;;
        esac
    done
    local final_list=""; if [ ${#excluded_map[@]} -gt 0 ]; then local keys=("${!excluded_map[@]}"); local old_ifs="$IFS"; IFS=,; final_list="${keys[*]}"; IFS="$old_ifs"; fi
    WATCHTOWER_EXCLUDE_LIST="$final_list"
}

manage_tasks(){
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi
        local -a items_array=( "1. ÂÅúÊ≠¢/ÁßªÈô§ Watchtower" "2. ÈáçÂª∫ Watchtower" )
        _render_menu "‚öôÔ∏è ‰ªªÂä°ÁÆ°ÁêÜ ‚öôÔ∏è" "${items_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËØ∑ÈÄâÊã©, ÊàñÊåâ Enter ËøîÂõû: " choice < /dev/tty
        case "$choice" in
            1) 
                if JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then 
                    if confirm_action "Á°ÆÂÆöÁßªÈô§ WatchtowerÔºü"; then 
                        set +e; JB_SUDO_LOG_QUIET="true" run_with_sudo docker rm -f watchtower &>/dev/null; set -e
                        WATCHTOWER_ENABLED="false"; save_config
                        log_success "Watchtower Â∑≤ÁßªÈô§„ÄÇ"
                    fi
                else 
                    log_warn "Watchtower Êú™ËøêË°å„ÄÇ"
                fi
                press_enter_to_continue 
                ;;
            2) 
                if JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then 
                    if confirm_action "Á°ÆÂÆöË¶ÅÈáçÂª∫ Watchtower ÂêóÔºü"; then _rebuild_watchtower; else log_info "Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ"; fi
                else 
                    log_warn "Watchtower Êú™ËøêË°å„ÄÇ"
                fi
                press_enter_to_continue
                ;;
            "") return ;; 
            *) log_warn "Êó†ÊïàÈÄâÈ°π„ÄÇ"; sleep 1 ;;
        esac
    done
}

_format_and_highlight_log_line(){
    local line="$1"
    local ts=$(_parse_watchtower_timestamp_from_log_line "$line")
    case "$line" in
        *"Session done"*)
            local f s u; f=$(echo "$line" | sed -n 's/.*Failed=\([0-9]*\).*/\1/p'); s=$(echo "$line" | sed -n 's/.*Scanned=\([0-9]*\).*/\1/p'); u=$(echo "$line" | sed -n 's/.*Updated=\([0-9]*\).*/\1/p')
            local c="$GREEN"; if [ "${f:-0}" -gt 0 ]; then c="$YELLOW"; fi
            printf "%s %b%s%b\n" "$ts" "$c" "‚úÖ Êâ´Êèè: ${s:-?}, Êõ¥Êñ∞: ${u:-?}, Â§±Ë¥•: ${f:-?}" "$NC" ;;
        *"Found new"*) printf "%s %b%s%b\n" "$ts" "$GREEN" "üÜï ÂèëÁé∞Êñ∞ÈïúÂÉè: $(echo "$line" | sed -n 's/.*Found new \(.*\) image .*/\1/p')" "$NC" ;;
        *"Stopping "*) printf "%s %b%s%b\n" "$ts" "$GREEN" "üõë ÂÅúÊ≠¢ÊóßÂÆπÂô®: $(echo "$line" | sed -n 's/.*Stopping \/\([^ ]*\).*/\/\1/p')" "$NC" ;;
        *"Creating "*) printf "%s %b%s%b\n" "$ts" "$GREEN" "üöÄ ÂàõÂª∫Êñ∞ÂÆπÂô®: $(echo "$line" | sed -n 's/.*Creating \/\(.*\).*/\/\1/p')" "$NC" ;;
        *"No new images found"*) printf "%s %b%s%b\n" "$ts" "$CYAN" "‚ÑπÔ∏è Êú™ÂèëÁé∞Êñ∞ÈïúÂÉè„ÄÇ" "$NC" ;;
        *"Scheduling first run"*) printf "%s %b%s%b\n" "$ts" "$GREEN" "üïí È¶ñÊ¨°ËøêË°åÂ∑≤Ë∞ÉÂ∫¶" "$NC" ;;
        *"Starting Watchtower"*) printf "%s %b%s%b\n" "$ts" "$GREEN" "‚ú® Watchtower Â∑≤ÂêØÂä®" "$NC" ;;
        *)
            if echo "$line" | grep -qiE "\b(unauthorized|failed|error|fatal)\b"; then
                printf "%s %b%s%b\n" "$ts" "$RED" "‚ùå ÈîôËØØ: $(echo "$line" | sed -E 's/.*(level=(error|warn)|time="[^"]*")\s*//g')" "$NC"
            fi ;;
    esac
}

get_updates_last_24h(){
    if ! JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then echo ""; return 1; fi
    local since; since=$(date -d "24 hours ago" '+%Y-%m-%dT%H:%M:%S' 2>/dev/null || true)
    local raw_logs
    if [ -n "$since" ]; then raw_logs=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker logs --since "$since" watchtower 2>&1 || true); fi
    if [ -z "$raw_logs" ]; then raw_logs=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker logs --tail 200 watchtower 2>&1 || true); fi
    echo "$raw_logs" | grep -E "Found new|Stopping|Creating|Session done|No new|Scheduling first run|Starting Watchtower|unauthorized|failed|error|fatal" || true
}

show_container_info() { 
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi; 
        local -a content_lines_array=()
        content_lines_array+=("ÁºñÂè∑ ÂêçÁß∞           ÈïúÂÉè                               Áä∂ÊÄÅ") 
        
        local -a containers=()
        local i=1
        while IFS='|' read -r name image status; do 
            containers+=("$name")
            local status_colored="$status"
            if echo "$status" | grep -qE '^Up'; then status_colored="${GREEN}ËøêË°å‰∏≠${NC}"; elif echo "$status" | grep -qE '^Exited|Created'; then status_colored="${RED}Â∑≤ÈÄÄÂá∫${NC}"; else status_colored="${YELLOW}${status}${NC}"; fi
            content_lines_array+=("$(printf "%2d   %-15s %-35s %s" "$i" "$name" "$image" "$status_colored")")
            i=$((i + 1))
        done < <(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}|{{.Image}}|{{.Status}}')
        
        content_lines_array+=("" "a. ÂÖ®ÈÉ®ÂêØÂä® (Start All)   s. ÂÖ®ÈÉ®ÂÅúÊ≠¢ (Stop All)")
        _render_menu "üìã ÂÆπÂô®ÁÆ°ÁêÜ üìã" "${content_lines_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËæìÂÖ•ÁºñÂè∑ÁÆ°ÁêÜ, 'a'/'s' ÊâπÈáèÊìç‰Ωú, ÊàñÊåâ Enter ËøîÂõû: " choice < /dev/tty
        case "$choice" in 
            "") return ;;
            a|A) if confirm_action "Á°ÆÂÆöË¶ÅÂêØÂä®ÊâÄÊúâÂ∑≤ÂÅúÊ≠¢ÁöÑÂÆπÂô®Âêó?"; then log_info "Ê≠£Âú®ÂêØÂä®..."; local stopped; stopped=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -aq -f status=exited); if [ -n "$stopped" ]; then JB_SUDO_LOG_QUIET="true" run_with_sudo docker start $stopped &>/dev/null || true; fi; log_success "Êìç‰ΩúÂÆåÊàê„ÄÇ"; press_enter_to_continue; else log_info "Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ"; fi ;; 
            s|S) if confirm_action "Ë≠¶Âëä: Á°ÆÂÆöË¶ÅÂÅúÊ≠¢ÊâÄÊúâÊ≠£Âú®ËøêË°åÁöÑÂÆπÂô®Âêó?"; then log_info "Ê≠£Âú®ÂÅúÊ≠¢..."; local running; running=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -q); if [ -n "$running" ]; then JB_SUDO_LOG_QUIET="true" run_with_sudo docker stop $running &>/dev/null || true; fi; log_success "Êìç‰ΩúÂÆåÊàê„ÄÇ"; press_enter_to_continue; else log_info "Êìç‰ΩúÂ∑≤ÂèñÊ∂à„ÄÇ"; fi ;; 
            *)
                if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#containers[@]} ]; then log_warn "Êó†ÊïàËæìÂÖ•ÊàñÁºñÂè∑Ë∂ÖËåÉÂõ¥„ÄÇ"; sleep 1; continue; fi
                local selected_container="${containers[$((choice - 1))]}"; if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi
                local -a action_items_array=( "1. Êü•ÁúãÊó•Âøó (Logs)" "2. ÈáçÂêØ (Restart)" "3. ÂÅúÊ≠¢ (Stop)" "4. Âà†Èô§ (Remove)" "5. Êü•ÁúãËØ¶ÊÉÖ (Inspect)" "6. ËøõÂÖ•ÂÆπÂô® (Exec)" )
                _render_menu "Êìç‰ΩúÂÆπÂô®: ${selected_container}" "${action_items_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËØ∑ÈÄâÊã©, ÊàñÊåâ Enter ËøîÂõû: " action < /dev/tty
                case "$action" in 
                    1) echo -e "${YELLOW}Êó•Âøó (Ctrl+C ÂÅúÊ≠¢)...${NC}"; trap '' INT; JB_SUDO_LOG_QUIET="true" run_with_sudo docker logs -f --tail 100 "$selected_container" || true; trap 'echo -e "\nÊìç‰ΩúË¢´‰∏≠Êñ≠„ÄÇ"; exit 10' INT; press_enter_to_continue ;;
                    2) echo "ÈáçÂêØ‰∏≠..."; if JB_SUDO_LOG_QUIET="true" run_with_sudo docker restart "$selected_container"; then echo -e "${GREEN}‚úÖ ÊàêÂäü„ÄÇ${NC}"; else echo -e "${RED}‚ùå Â§±Ë¥•„ÄÇ${NC}"; fi; sleep 1 ;; 
                    3) echo "ÂÅúÊ≠¢‰∏≠..."; if JB_SUDO_LOG_QUIET="true" run_with_sudo docker stop "$selected_container"; then echo -e "${GREEN}‚úÖ ÊàêÂäü„ÄÇ${NC}"; else echo -e "${RED}‚ùå Â§±Ë¥•„ÄÇ${NC}"; fi; sleep 1 ;; 
                    4) if confirm_action "Ë≠¶Âëä: ËøôÂ∞ÜÊ∞∏‰πÖÂà†Èô§ '${selected_container}'ÔºÅ"; then echo "Âà†Èô§‰∏≠..."; if JB_SUDO_LOG_QUIET="true" run_with_sudo docker rm -f "$selected_container"; then echo -e "${GREEN}‚úÖ ÊàêÂäü„ÄÇ${NC}"; else echo -e "${RED}‚ùå Â§±Ë¥•„ÄÇ${NC}"; fi; sleep 1; else echo "Â∑≤ÂèñÊ∂à„ÄÇ"; fi ;; 
                    5) _print_header "ÂÆπÂô®ËØ¶ÊÉÖ: ${selected_container}"; (JB_SUDO_LOG_QUIET="true" run_with_sudo docker inspect "$selected_container" | jq '.' 2>/dev/null || JB_SUDO_LOG_QUIET="true" run_with_sudo docker inspect "$selected_container") | less -R ;; 
                    6) if [ "$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker inspect --format '{{.State.Status}}' "$selected_container")" != "running" ]; then log_warn "ÂÆπÂô®Êú™Âú®ËøêË°åÔºåÊó†Ê≥ïËøõÂÖ•„ÄÇ"; else log_info "Â∞ùËØïËøõÂÖ•ÂÆπÂô®... (ËæìÂÖ• 'exit' ÈÄÄÂá∫)"; JB_SUDO_LOG_QUIET="true" run_with_sudo docker exec -it "$selected_container" /bin/sh -c "[ -x /bin/bash ] && /bin/bash || /bin/sh" || true; fi; press_enter_to_continue ;; 
                    *) ;; 
                esac
            ;;
        esac
    done
}

show_watchtower_details(){
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi
        local title="üìä Watchtower ËØ¶ÊÉÖ‰∏éÁÆ°ÁêÜ üìä"
        local interval raw_logs COUNTDOWN updates
        
        set +e; interval=$(get_watchtower_inspect_summary); raw_logs=$(get_watchtower_all_raw_logs); set -e
        COUNTDOWN=$(_get_watchtower_remaining_time "${interval}" "${raw_logs}")
        
        local -a content_lines_array=(
            "‚è±Ô∏è  ${CYAN}ÂΩìÂâçÁä∂ÊÄÅ${NC}"
            "    ${YELLOW}‰∏äÊ¨°Ê¥ªÂä®:${NC} $(get_last_session_time || echo 'N/A')" 
            "    ${YELLOW}‰∏ãÊ¨°Ê£ÄÊü•:${NC} ${COUNTDOWN}"
            "" 
            "üìú  ${CYAN}ÊúÄËøë 24h ÊëòË¶Å${NC}"
        )
        
        updates=$(get_updates_last_24h || true)
        if [ -z "$updates" ]; then content_lines_array+=("    Êó†Êó•Âøó‰∫ã‰ª∂„ÄÇ"); else while IFS= read -r line; do content_lines_array+=("    $(_format_and_highlight_log_line "$line")"); done <<< "$updates"; fi
        
        _render_menu "$title" "${content_lines_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> [1] ÂÆûÊó∂Êó•Âøó, [2] ÂÆπÂô®ÁÆ°ÁêÜ, [3] Ëß¶ÂèëÊâ´Êèè, [Enter] ËøîÂõû: " pick < /dev/tty
        case "$pick" in
            1) 
                if JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.Names}}' | grep -qFx 'watchtower'; then 
                    echo -e "\nÊåâ Ctrl+C ÂÅúÊ≠¢..."; 
                    trap '' INT; JB_SUDO_LOG_QUIET="true" run_with_sudo docker logs -f --tail 100 watchtower || true; trap 'echo -e "\nÊìç‰ΩúË¢´‰∏≠Êñ≠„ÄÇ"; exit 10' INT; 
                    press_enter_to_continue; 
                else 
                    echo -e "\n${RED}Watchtower Êú™ËøêË°å„ÄÇ${NC}"; press_enter_to_continue; 
                fi ;;
            2) show_container_info ;;
            3) run_watchtower_once; press_enter_to_continue ;;
            *) return ;;
        esac
    done
}

view_and_edit_config(){
    local -a config_items=("TG Token|TG_BOT_TOKEN|string" "TG Chat ID|TG_CHAT_ID|string" "Email|EMAIL_TO|string" "ÊéíÈô§ÂàóË°®|WATCHTOWER_EXCLUDE_LIST|string_list" "È¢ùÂ§ñÂèÇÊï∞|WATCHTOWER_EXTRA_ARGS|string" "Ë∞ÉËØïÊ®°Âºè|WATCHTOWER_DEBUG_ENABLED|bool" "Ê£ÄÊü•Èó¥Èöî|WATCHTOWER_CONFIG_INTERVAL|interval" "Watchtower ÂêØÁî®Áä∂ÊÄÅ|WATCHTOWER_ENABLED|bool" "Cron ÊâßË°åÂ∞èÊó∂|CRON_HOUR|number_range|0-23" "Êó†Êõ¥Êñ∞Êó∂ÈÄöÁü•|WATCHTOWER_NOTIFY_ON_NO_UPDATES|bool")
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi; load_config; 
        local -a content_lines_array=(); local i
        for i in "${!config_items[@]}"; do
            local item="${config_items[$i]}"; local label; label=$(echo "$item" | cut -d'|' -f1); local var_name; var_name=$(echo "$item" | cut -d'|' -f2); local type; type=$(echo "$item" | cut -d'|' -f3); local extra; extra=$(echo "$item" | cut -d'|' -f4); local current_value="${!var_name}"; local display_text=""; local color="${CYAN}"
            case "$type" in
                string) if [ -n "$current_value" ]; then color="${GREEN}"; display_text="$current_value"; else color="${RED}"; display_text="Êú™ËÆæÁΩÆ"; fi ;;
                string_list) if [ -n "$current_value" ]; then color="${YELLOW}"; display_text="${current_value//,/, }"; else color="${CYAN}"; display_text="Êó†"; fi ;;
                bool) if [ "$current_value" = "true" ]; then color="${GREEN}"; display_text="ÊòØ"; else color="${CYAN}"; display_text="Âê¶"; fi ;;
                interval) display_text=$(_format_seconds_to_human "$current_value"); if [ "$display_text" != "N/A" ] && [ -n "$current_value" ]; then color="${GREEN}"; else color="${RED}"; display_text="Êú™ËÆæÁΩÆ"; fi ;;
                number_range) if [ -n "$current_value" ]; then color="${GREEN}"; display_text="$current_value"; else color="${RED}"; display_text="Êú™ËÆæÁΩÆ"; fi ;;
            esac
            content_lines_array+=("$(printf "%2d. %s: %s%s%s" "$((i + 1))" "$label" "$color" "$display_text" "$NC")")
        done
        _render_menu "‚öôÔ∏è ÈÖçÁΩÆÊü•Áúã‰∏éÁºñËæë (Â∫ïÂ±Ç) ‚öôÔ∏è" "${content_lines_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËæìÂÖ•ÁºñÂè∑ÁºñËæë, ÊàñÊåâ Enter ËøîÂõû: " choice < /dev/tty
        if [ -z "$choice" ]; then return; fi
        if ! echo "$choice" | grep -qE '^[0-9]+$' || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#config_items[@]}" ]; then log_warn "Êó†ÊïàÈÄâÈ°π„ÄÇ"; sleep 1; continue; fi
        local selected_index=$((choice - 1)); local selected_item="${config_items[$selected_index]}"; local label; label=$(echo "$selected_item" | cut -d'|' -f1); local var_name; var_name=$(echo "$selected_item" | cut -d'|' -f2); local type; type=$(echo "$selected_item" | cut -d'|' -f3); local extra; extra=$(echo "$selected_item" | cut -d'|' -f4); local current_value="${!var_name}";
        
        case "$type" in
            string|string_list) 
                local new_value_input; new_value_input=$(_prompt_user_input "ËØ∑ËæìÂÖ•Êñ∞ÁöÑ '$label' (ÂΩìÂâç: $current_value): " "$current_value"); declare "$var_name"="${new_value_input}" ;;
            bool) 
                local new_value_input; new_value_input=$(_prompt_user_input "ÊòØÂê¶ÂêØÁî® '$label'? (y/N, ÂΩìÂâç: $current_value): " ""); if echo "$new_value_input" | grep -qE '^[Yy]$'; then declare "$var_name"="true"; else declare "$var_name"="false"; fi ;;
            interval) 
                local new_value; new_value=$(_prompt_for_interval "${current_value:-300}" "‰∏∫ '$label' ËÆæÁΩÆÊñ∞Èó¥Èöî"); if [ -n "$new_value" ]; then declare "$var_name"="$new_value"; fi ;;
            number_range)
                local min; min=$(echo "$extra" | cut -d'-' -f1); local max; max=$(echo "$extra" | cut -d'-' -f2)
                while true; do 
                    local new_value_input; new_value_input=$(_prompt_user_input "ËØ∑ËæìÂÖ•Êñ∞ÁöÑ '$label' (${min}-${max}, ÂΩìÂâç: $current_value): " "$current_value")
                    if [ -z "$new_value_input" ]; then break; fi
                    if echo "$new_value_input" | grep -qE '^[0-9]+$' && [ "$new_value_input" -ge "$min" ] && [ "$new_value_input" -le "$max" ]; then declare "$var_name"="$new_value_input"; break; else log_warn "Êó†ÊïàËæìÂÖ•, ËØ∑ËæìÂÖ• ${min} Âà∞ ${max} ‰πãÈó¥ÁöÑÊï∞Â≠ó„ÄÇ"; fi
                done ;;
        esac
        save_config; log_info "'$label' Â∑≤Êõ¥Êñ∞„ÄÇ"; sleep 1
    done
}

main_menu(){
    while true; do
        if [ "${JB_ENABLE_AUTO_CLEAR:-false}" = "true" ]; then clear; fi; load_config
        local STATUS_RAW="Êú™ËøêË°å"; if JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps --format '{{.Names}}' | grep -qFx 'watchtower'; then STATUS_RAW="Â∑≤ÂêØÂä®"; fi
        local STATUS_COLOR; if [ "$STATUS_RAW" = "Â∑≤ÂêØÂä®" ]; then STATUS_COLOR="${GREEN}Â∑≤ÂêØÂä®${NC}"; else STATUS_COLOR="${RED}Êú™ËøêË°å${NC}"; fi
        local interval=""; local raw_logs=""; if [ "$STATUS_RAW" = "Â∑≤ÂêØÂä®" ]; then interval=$(get_watchtower_inspect_summary || true); raw_logs=$(get_watchtower_all_raw_logs || true); fi
        local COUNTDOWN=$(_get_watchtower_remaining_time "${interval}" "${raw_logs}")
        local TOTAL; TOTAL=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps -a --format '{{.ID}}' 2>/dev/null | wc -l || echo "0")
        local RUNNING; RUNNING=$(JB_SUDO_LOG_QUIET="true" run_with_sudo docker ps --format '{{.ID}}' 2>/dev/null | wc -l || echo "0"); local STOPPED=$((TOTAL - RUNNING))
        
        local header_text="Watchtower ÁÆ°ÁêÜ"
        local -a content_array=(
            "üïù Watchtower Áä∂ÊÄÅ: ${STATUS_COLOR}" 
            "‚è≥ ‰∏ãÊ¨°Ê£ÄÊü•: ${COUNTDOWN}" 
            "üì¶ ÂÆπÂô®Ê¶ÇËßà: ÊÄªËÆ° $TOTAL (${GREEN}ËøêË°å‰∏≠ ${RUNNING}${NC}, ${RED}Â∑≤ÂÅúÊ≠¢ ${STOPPED}${NC})"
            ""
            "‰∏ªËèúÂçïÔºö" 
            "1. ÂêØÁî®Âπ∂ÈÖçÁΩÆ Watchtower" 
            "2. ÈÖçÁΩÆÈÄöÁü•" 
            "3. ‰ªªÂä°ÁÆ°ÁêÜ (ÂêØÂÅú/ÈáçÂª∫)"
            "4. Êü•Áúã/ÁºñËæëÈÖçÁΩÆ (Â∫ïÂ±Ç)"
            "5. ËØ¶ÊÉÖ‰∏éÊó•ÂøóÊëòË¶Å"
        )
        _render_menu "$header_text" "${content_array[@]}"; read -r -p " ‚îî‚îÄ‚îÄ> ËæìÂÖ•ÈÄâÈ°π [1-5] ÊàñÊåâ Enter ËøîÂõû: " choice < /dev/tty
        case "$choice" in
          1) configure_watchtower || true; press_enter_to_continue ;;
          2) notification_menu ;;
          3) manage_tasks ;;
          4) view_and_edit_config; _prompt_and_rebuild_watchtower_if_needed ;;
          5) show_watchtower_details ;;
          "") return 0 ;;
          *) log_warn "Êó†ÊïàÈÄâÈ°π„ÄÇ"; sleep 1 ;;
        esac
    done
}

main(){ 
    trap 'echo -e "\nÊìç‰ΩúË¢´‰∏≠Êñ≠„ÄÇ"; exit 10' INT
    log_info "Ê¨¢Ëøé‰ΩøÁî® Watchtower Ê®°Âùó ${SCRIPT_VERSION}" >&2
    main_menu
    exit 10
}

main "$@"
